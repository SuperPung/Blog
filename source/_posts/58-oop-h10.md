---
url: oop-h10
title: Java 集合练习（续）
date: 2021-03-28 15:01:08
categories: [技术]
tags: [Java]
---

OOP h10

<!--more-->

{% note warning %}

* 不可以修改类的名字、包名、和固有的几个方法名以及方法的可见性
* 可以增加其他方法、属性、类
* 可以引用 jdk 的类
* 不要引用 jdk1.8 以外第三方的包

{% endnote %}

{% note info %}

将一个字符串中字符按出现频率的高到低排序返回，如果两个字符出现的频率一样，则将最先出现的字符排在前面

例如：

- `orderChar("abcdefg")` 返回 `"abcdefg"`
- `orderChar("abcdefgg")` 返回 `"gabcdef"`
- `orderChar("abcdefgge")` 返回 `"egabcdf"`
- `orderChar("ab大学软件学院")` 返回 `"学ab大软件院"`

{% endnote %}

按照 h09 的思路，先用 map 存储字符串的每个字符为「键」，字符出现的频率为「值」。

然后再对 map 中的值进行排序，然后将此顺序下的键组成字符串返回。

---

对 map 排序，首先想到 `TreeMap`。但 `TreeMap` 默认对「键」排序，而不是「值」，所以需要单独实现对 map 的排序。

可以将 map 中的键值对存放到列表中，然后重写列表的 `sort` 方法，使之按照键值对的值来降序排序。

{% note primary %}

#### Java Lambda 表达式

Lambda 表达式，也可称为「闭包」，它是推动 Java 8 发布的最重要新特性。

Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。

使用 Lambda 表达式可以使代码变的更加简洁紧凑。

Lambda 表达式的语法格式如下：

```java
(parameters) -> expression
或
(parameters) -> { statements; }
```

以下是 Lambda 表达式的重要特征:

- **可选类型声明**：不需要声明参数类型，编译器可以统一识别参数值。
- **可选的参数圆括号**：一个参数无需定义圆括号，但多个参数需要定义圆括号。
- **可选的大括号**：如果主体包含了一个语句，就不需要使用大括号。
- **可选的返回关键字**：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。

{% endnote %}

```java
package com.huawei.classroom.student.h10;

import java.util.*;

/**
 *
 * @author super
 *
 */
public class Home10 {
	public Home10() {
	}
	/**
	 * 将一个字符串中字符按出现频率的高到低排序返回，如果两个字符出现的频率一样，则将最先出现的字符排在前面
	 * 例如：orderChar(“abcdefg”)返回 “abcdefg”
	 * orderChar(“abcdefgg”)返回 “gabcdef”
	 * orderChar(“abcdefgge”)返回 “egabcdf”
	 * orderChar(“ab大学软件学院”)返回 “学ab大软件院”
	 * @param content
	 * @return
	 */
	public String orderChar(String content) {
    // 创建映射，存放字符，计算频率
		int i;
		HashMap<Character, Integer> map = new HashMap<>();// 映射
		List<Map.Entry<Character, Integer>> mapList;// 列表
		StringBuilder ans = new StringBuilder();// 字符数组
		for (i = 0; i < content.length(); i++) {
			char cha = content.charAt(i);
			if (!map.containsKey(cha)) {
				map.put(cha, 1);
			} else {
				map.put(cha, map.get(cha) + 1);
			}
		}
		// 将键值对存放到列表
		mapList = new ArrayList<>(map.entrySet());
		mapList.sort((o1, o2) -> o2.getValue().compareTo(o1.getValue()));// 重写排序方法，使用 Lambda 表达式，注意为降序

		for (Map.Entry<Character, Integer> mapListElement : mapList) {
			ans.append(mapListElement.getKey());// 使用 StringBuilder 提高效率，不直接用 String
		}
		return ans.toString();
	}

}
```
